#include "Transforms.hpp"

#include <llvm/IR/IRBuilder.h>

#include "DeriveZeroMBA.hpp"

// zero_expr and x cannot be null
static llvm::Value *GetObfuscatedValue(llvm::IRBuilder<> &builder, llvm::Value *zero_expr, llvm::Value *x) {
    // return a version of x (that is always equal to x) that has some
    // binary operator applied to it
    // zero_expr cannot be too simple or this transform will be optimized
    // out by the compiler.  zero_expr should be generated by GenerateRandomMBAIdentity
    // zero_expr must be a llvm::Value that is ALWAYS equal to zero
    switch (std::rand() % 4) {
        case 0:
            // x + 0 = x
            return builder.CreateAdd(x, zero_expr);
            break;
        case 1:
            // x - 0 = x
            return builder.CreateSub(x, zero_expr);
            break;
        case 2:
            // x ^ 0 = x
            return builder.CreateXor(x, zero_expr);
            break;
        case 3:
            // x | 0 = x
            return builder.CreateOr(x, zero_expr);
            break;
    }
    return nullptr;
}

namespace obfus {
bool TransformBinaryOperatorBasicBlock(llvm::BasicBlock &BB) {
    bool changed = false;

    for (auto I = BB.begin(); I != BB.end(); ++I) {
        // Skip non-binary (e.g. unary or compare) instructions
        const auto bin_op = llvm::dyn_cast<llvm::BinaryOperator>(I);
        if (!bin_op || !bin_op->getType()->isIntegerTy()) {
            continue;
        }

        llvm::IRBuilder<> builder(bin_op);

        // useful variables in building the instruction for substitution
        const auto x = bin_op->getOperand(0);
        const auto y = bin_op->getOperand(1);
        // may not actually exist in which case y will just be selected
        const auto const_operand = (llvm::dyn_cast<llvm::ConstantInt>(x)) ? x : y;
        const auto non_const_operand = (!llvm::dyn_cast<llvm::ConstantInt>(x)) ? x : y;

        std::vector<llvm::Value *> vars{const_operand, non_const_operand, llvm::ConstantInt::get(bin_op->getType(), std::rand() % 255)};
        // std::vector<llvm::Value *> vars{const_operand, non_const_operand, llvm::ConstantInt::get(bin_op->getType(), std::rand() % 255), llvm::ConstantInt::get(bin_op->getType(), std::rand() % 255)};

        const auto zero_expr = obfus::GenerateRandomMBAIdentity(builder, bin_op->getType(), vars);
        const auto x_expr = GetObfuscatedValue(builder, zero_expr, x);

#ifdef DEBUG
        llvm::errs() << "Opcode: Instruction::" << I->getOpcodeName() << "\n";
#endif
        llvm::Value *new_value = nullptr;
        switch (I->getOpcode()) {
            case llvm::Instruction::Add:
                new_value = builder.CreateAdd(x_expr, y);
                break;
            case llvm::Instruction::Sub:
                new_value = builder.CreateSub(x_expr, y);
                break;
            case llvm::Instruction::Xor:
                new_value = builder.CreateXor(x_expr, y);
                break;
            case llvm::Instruction::Or:
                new_value = builder.CreateOr(x_expr, y);
                break;
            case llvm::Instruction::And:
                new_value = builder.CreateAnd(x_expr, y);
                break;
        }
        // if we have something to replace the instruction with, replace it
        if (new_value) {
            bin_op->replaceAllUsesWith(new_value);
            changed = true;
        }
    }
    return changed;
}

bool TransformIntegerConstants(llvm::BasicBlock &BB) {
    bool changed = false;

    // see https://sci-hub.ee/https://link.springer.com/chapter/10.1007/978-3-540-77535-5_5
    // TODO: turn integer constants into complex expressions
    for (auto I = BB.begin(); I != BB.end(); ++I) {
        const auto icmp_op = llvm::dyn_cast<llvm::ICmpInst>(I);
        if (!icmp_op || !icmp_op->getType()->isIntegerTy()) {
            // if its not an integer comparison, go to next instruction
            continue;
        }
        // if we do not have two operands
        if (icmp_op->getNumOperands() != 2) {
            continue;
        }

        const auto x = icmp_op->getOperand(0);
        const auto y = icmp_op->getOperand(1);
        const auto x_value = llvm::dyn_cast<llvm::ConstantInt>(x);
        const auto y_value = llvm::dyn_cast<llvm::ConstantInt>(y);
        // if neither are const integers
        if (!x_value && !y_value) {
            continue;
        }
        const int value_replace_index = (x_value) ? 0 : 1;
        const auto value_replace = (value_replace_index == 0) ? x_value : y_value;

        const auto same = (value_replace_index == 0) ? y : x;
        const auto int_type = value_replace->getType();

        llvm::IRBuilder<> builder(icmp_op);

        std::vector<llvm::Value *> vars{llvm::ConstantInt::get(int_type, std::rand() % 255), same};
        // std::vector<llvm::Value *> vars{llvm::ConstantInt::get(int_type, std::rand() % 255), same, llvm::ConstantInt::get(int_type, std::rand() % 255)};
        // std::vector<llvm::Value *> vars{llvm::ConstantInt::get(int_type, std::rand() % 255), same, llvm::ConstantInt::get(int_type, std::rand() % 255), llvm::ConstantInt::get(int_type, std::rand() % 255)};

        const auto zero_expr = obfus::GenerateRandomMBAIdentity(builder, int_type, vars);
        if (value_replace->getSExtValue() == 0) {
            icmp_op->setOperand(value_replace_index, zero_expr);
        } else {
            icmp_op->setOperand(value_replace_index, GetObfuscatedValue(builder, zero_expr, value_replace));
        }
        changed = true;
#ifdef DEBUG
        llvm::errs() << "Replaced constant: " << value_replace->getSExtValue() << "\n";
#endif
    }

    return changed;
}

bool TransformControlFlow(llvm::BasicBlock &BB) {
    bool changed = false;

    // see https://sci-hub.ee/https://link.springer.com/chapter/10.1007/978-3-540-77535-5_5
    // TODO: turn integer constants into complex expressions
    for (auto I = BB.begin(); I != BB.end(); ++I) {
        const auto branch = llvm::dyn_cast<llvm::BranchInst>(I);
        // ignore goto statements
        if (!branch || !branch->isConditional() || !branch->getCondition()->getType()->isIntegerTy()) {
            continue;
        }
        const auto icmp_op = llvm::dyn_cast<llvm::ICmpInst>(branch->getCondition());
        if (!icmp_op || icmp_op->getNumOperands() != 2 || !icmp_op->getType()->isIntegerTy()) {
            continue;
        }

#ifdef DEBUG
        llvm::errs() << "Branch: " << icmp_op->getPredicate() << "\n";
#endif
        const auto x = icmp_op->getOperand(0);
        const auto y = icmp_op->getOperand(1);
        const auto int_type = x->getType();
        llvm::IRBuilder<> builder(icmp_op);
        std::vector<llvm::Value *> vars{x, y, llvm::ConstantInt::get(int_type, std::rand() % 255)};

        const auto zero_expr_x = obfus::GenerateRandomMBAIdentity(builder, int_type, vars);
        const auto zero_expr_y = obfus::GenerateRandomMBAIdentity(builder, int_type, vars);
        const auto x_expr = GetObfuscatedValue(builder, zero_expr_y, x);
        const auto y_expr = GetObfuscatedValue(builder, zero_expr_y, y);
        icmp_op->setOperand(0, x_expr);
        icmp_op->setOperand(1, y_expr);
        changed = true;
    }

    return changed;
}

}  // namespace obfus