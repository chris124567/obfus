#include "Obfus.hpp"

#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/PassManager.h>
#include <llvm/Passes/PassBuilder.h>
#include <llvm/Passes/PassPlugin.h>
#include <llvm/Transforms/Utils/BasicBlockUtils.h>

#include <cstdlib>
#include <iostream>

#include "DeriveZeroMBA.hpp"

using namespace llvm;

static Value *GetObfuscatedValue(IRBuilder<> &builder, Value *zero_expr, Value *x) {
    // return a version of x that has some binary operator applied to it
    // zero_expr cannot be too simple or this transform will be optimized
    // out by the compiler.  zero_expr should be generated by GenerateRandomMBAIdentity
    // zero_expr must be a llvm::Value that is ALWAYS equal to zero
    Value *x_expr = nullptr;
    switch (std::rand() % 4) {
        case 0:
            // x + 0 = x
            x_expr = builder.CreateAdd(x, zero_expr);
            break;
        case 1:
            // x - 0 = x
            x_expr = builder.CreateSub(x, zero_expr);
            break;
        case 2:
            // x ^ 0 = x
            x_expr = builder.CreateXor(x, zero_expr);
            break;
        case 3:
            // x | 0 = x
            x_expr = builder.CreateOr(x, zero_expr);
            break;
    }
    return x_expr;
}

static bool TransformIntegerConstants(BasicBlock &BB) {
    bool changed = false;

    // see https://sci-hub.ee/https://link.springer.com/chapter/10.1007/978-3-540-77535-5_5
    // TODO: turn integer constants into complex expressions
    for (auto I = BB.begin(); I != BB.end(); ++I) {
        const auto icmp_op = dyn_cast<ICmpInst>(I);
        if (!icmp_op || !icmp_op->getType()->isIntegerTy()) {
            // if its not an integer comparison, go to next instruction
            continue;
        }
        // if we do not have two operands
        if (icmp_op->getNumOperands() != 2) {
            continue;
        }

        const auto x = icmp_op->getOperand(0);
        const auto y = icmp_op->getOperand(1);
        const auto x_value = dyn_cast<ConstantInt>(x);
        const auto y_value = dyn_cast<ConstantInt>(y);
        // if neither are const integers
        if (!x_value && !y_value) {
            continue;
        }
        const int value_replace_index = (x_value) ? 0 : 1;
        const auto value_replace = (value_replace_index == 0) ? x_value : y_value;

        const auto same = (value_replace_index == 0) ? y : x;
        const auto int_type = value_replace->getType();

        llvm::IRBuilder<> builder(icmp_op);
        std::vector<Value *> vars{ConstantInt::get(int_type, std::rand() % 255), same, ConstantInt::get(int_type, std::rand() % 255)};
        const auto zero_expr = GenerateRandomMBAIdentity(builder, int_type, vars);
        if (value_replace->getSExtValue() == 0) {
            icmp_op->setOperand(value_replace_index, zero_expr);
        } else {
            icmp_op->setOperand(value_replace_index, GetObfuscatedValue(builder, zero_expr, value_replace));
        }
        changed = true;
    }

    return changed;
}

static bool TransformBinaryOperatorBasicBlock(BasicBlock &BB) {
    bool changed = false;

    for (auto I = BB.begin(); I != BB.end(); ++I) {
        // Skip non-binary (e.g. unary or compare) instructions
        const auto bin_op = dyn_cast<BinaryOperator>(I);
        if (!bin_op || !bin_op->getType()->isIntegerTy()) {
            continue;
        }

        IRBuilder<> builder(bin_op);

        // useful variables in building the instruction for substitution
        const auto x = bin_op->getOperand(0);
        const auto y = bin_op->getOperand(1);
        // may not actually exist in which case y will just be selected
        const auto const_operand = (dyn_cast<ConstantInt>(x)) ? x : y;
        const auto non_const_operand = (!dyn_cast<ConstantInt>(x)) ? x : y;

        Value *new_value = nullptr;

        // std::vector<Value *> vars{ConstantInt::get(bin_op->getType(), std::rand() % 255), non_const_operand};
        std::vector<Value *> vars{const_operand, non_const_operand, ConstantInt::get(bin_op->getType(), std::rand() % 255)};
        const auto zero_expr = GenerateRandomMBAIdentity(builder, bin_op->getType(), vars);
        const auto x_expr = GetObfuscatedValue(builder, zero_expr, x);

#ifdef DEBUG
        errs() << "Opcode: Instruction::" << I->getOpcodeName() << "\n";
#endif
        switch (I->getOpcode()) {
            case Instruction::Add:
                new_value = builder.CreateAdd(x_expr, y);
                break;
            case Instruction::Sub:
                new_value = builder.CreateSub(x_expr, y);
                break;
            case Instruction::Xor:
                new_value = builder.CreateXor(x_expr, y);
                break;
            case Instruction::Or:
                new_value = builder.CreateOr(x_expr, y);
                break;
            case Instruction::And:
                new_value = builder.CreateAnd(x_expr, y);
                break;
        }
        // if we have something to replace the instruction with, replace it
        if (new_value) {
            bin_op->replaceAllUsesWith(new_value);
            changed = true;
        }
    }
    return changed;
}

PreservedAnalyses Obfus::run(Function &F, FunctionAnalysisManager &) {
    bool changed = false;
    const auto &name = F.getName();

    if (name == "main") {
#ifdef DEBUG
        errs() << "Skipping " << name << ", blacklisted\n";
#endif
        // skip main for now because that has our tests
        return PreservedAnalyses::all();
    }

#ifdef DEBUG
    errs() << "Attempting " << name << "\n";
#endif

    for (auto &BB : F) {
        // ORIGINAL ORDER:
        changed |= TransformBinaryOperatorBasicBlock(BB);
        changed |= TransformIntegerConstants(BB);
        // NEW ORDER:
        // changed |= TransformIntegerConstants(BB);
        // changed |= TransformBinaryOperatorBasicBlock(BB);
    }

#ifdef DEBUG
    if (changed) {
        errs() << "Obfuscated " << F.getName() << "\n";
    } else {
        errs() << "Did not change " << F.getName() << "\n";
    }
#endif

    return changed ? PreservedAnalyses::none() : PreservedAnalyses::all();
};

// make our plugin load by default so it works with clang
extern "C" LLVM_ATTRIBUTE_WEAK ::PassPluginLibraryInfo
llvmGetPassPluginInfo() {
    return {LLVM_PLUGIN_API_VERSION, "Obfus Pass", LLVM_VERSION_STRING,
            [](PassBuilder &PB) {
                // constexpr const int seed = 0;
                const int seed = std::time(nullptr);
                errs() << "Random seed: " << seed << "\n";
                srand(seed);

                // for opt command
                PB.registerPipelineParsingCallback(
                    [](StringRef Name, FunctionPassManager &FPM,
                       ArrayRef<PassBuilder::PipelineElement>) {
                        FPM.addPass(Obfus());
                        return true;
                    });

                /*
                auto register for clang
                need to use at least O1 for it to register - there is no
                other "default" callback for clang we can get aside from
                the optimization ones
                there is two options - register before optimizations have run, or after.
                running before means some of your obfuscation will probably be obfuscated
                away.  this is useful during development to make sure you make your
                obfuscations more rigorous.  however in production in may be desirable
                to run obfuscations after optimizations, in which case you can uncomment
                the registerOptimizerLastEPCallback code and comment the registerPipelineStartEPCallback
                code
                */
                PB.registerPipelineStartEPCallback(
                    [](ModulePassManager &MPM) {
                        MPM.addPass(createModuleToFunctionPassAdaptor(Obfus()));
                    });
                // PB.registerOptimizerLastEPCallback(
                //     [](ModulePassManager &MPM, PassBuilder::OptimizationLevel) {
                //         MPM.addPass(createModuleToFunctionPassAdaptor(Obfus()));
                //     });
            }};
}
